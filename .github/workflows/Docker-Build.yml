name: Deploy to Portainer with Self-Hosted Runner

on:
  push:
    branches:
      - main  # Setzen Sie hier den Namen Ihres Haupt-Branches ein

jobs:
  build:
    runs-on: self-hosted  # Verwenden Sie den selbst gehosteten Runner

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Build Docker image
        run: |
         echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
         echo ${{ secrets.SUDO }} | sudo -S docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ secrets.CONTAINER_NAME }}:latest .

      - name: Push Docker image to Registry
        run: |
         echo ${{ secrets.SUDO }} | sudo -S --validate
         echo ${{ secrets.DOCKER_PASSWORD }} | sudo docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
         echo ${{ secrets.SUDO }} | sudo docker push ${{ secrets.DOCKER_USERNAME }}/${{ secrets.CONTAINER_NAME }}:latest
  deploy:
      runs-on: self-hosted  # Verwenden Sie den selbst gehosteten Runner
      needs: build
      steps:
        - name: Create & start container
          env:
            PORTAINER_URL: https://${{ secrets.PORTAINER_IP }}:9443
            ENDPOINT_ID: "2"
            IMAGE: docker.io/${{ secrets.DOCKER_USERNAME }}/${{ secrets.CONTAINER_NAME }}:latest
            API_KEY: ${{ secrets.PORTAINER_API_TOKEN }}
            CONTAINER_NAME: ${{ secrets.CONTAINER_NAME }}
            CONFIG_PATH: ${{ secrets.CONFIG_PATH }}      # absoluter Pfad zur .env auf dem Zielhost
            CONTAINER_PORT: "8124"                       # Port IM Container
            HOST_PORT: "8124"                            # Port auf dem Host
            CONTAINER_ENV_PATH: ".env"              # Zielpfad IM Container
          run: |
            set -euo pipefail
            command -v jq >/dev/null || sudo apt-get update && sudo apt-get install -y jq

            # Existenz der .env-Datei auf dem Zielhost pr√ºfen (sonst scheitert Docker mit 400)
            if [ ! -f "$CONFIG_PATH" ]; then
              echo "Fehler: CONFIG_PATH zeigt nicht auf eine Datei: $CONFIG_PATH"; exit 1
            fi

            # Alten Container entfernen (idempotent)
            OLD_ID=$(curl --insecure -sS -H "X-API-Key: $API_KEY" \
              "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/json?all=1" \
              | jq -r ".[] | select(.Names[]? == \"/$CONTAINER_NAME\") | .Id // empty")
            if [ -n "${OLD_ID:-}" ]; then
              curl --insecure -sS -X POST "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/$OLD_ID/stop" -H "X-API-Key: $API_KEY" || true
              curl --fail --insecure -sS -X DELETE "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/$OLD_ID?force=1&v=1" -H "X-API-Key: $API_KEY"
            fi

            # Create-Payload: .env-Datei readonly nach /app/.env mounten
            CREATE_PAYLOAD=$(jq -n \
              --arg img "$IMAGE" \
              --arg bind "${CONFIG_PATH}:${CONTAINER_ENV_PATH}:ro" \
              --arg cport "$CONTAINER_PORT" \
              --arg hport "$HOST_PORT" \
              '{
                "Image": $img,
                "HostConfig": {
                  "PortBindings": { ($cport + "/tcp"): [ { "HostPort": $hport } ] },
                  "Binds": [ $bind ],
                  "RestartPolicy": { "Name": "unless-stopped" }
                }
              }')

            RESP=$(curl --fail --insecure -sS -X POST \
              "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/create?name=$CONTAINER_NAME" \
              -H "X-API-Key: $API_KEY" \
              -H "Content-Type: application/json" \
              -d "$CREATE_PAYLOAD")

            CID=$(echo "$RESP" | jq -r '.Id')
            test -n "$CID"
