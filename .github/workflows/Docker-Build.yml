name: Deploy to Portainer with Self-Hosted Runner

on:
  push:
    branches:
      - main  # Setzen Sie hier den Namen Ihres Haupt-Branches ein

jobs:
  build:
    runs-on: self-hosted  # Verwenden Sie den selbst gehosteten Runner

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Build Docker image
        run: |
         echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
         echo ${{ secrets.SUDO }} | sudo -S docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ secrets.CONTAINER_NAME }}:latest .

      - name: Push Docker image to Registry
        run: |
         echo ${{ secrets.SUDO }} | sudo -S --validate
         echo ${{ secrets.DOCKER_PASSWORD }} | sudo docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
         echo ${{ secrets.SUDO }} | sudo docker push ${{ secrets.DOCKER_USERNAME }}/${{ secrets.CONTAINER_NAME }}:latest
  deploy:
    runs-on: self-hosted
    needs: build
    steps:
      - name: Create & start container (Portainer API)
        env:
          PORTAINER_URL: https://${{ secrets.PORTAINER_IP }}:9443
          ENDPOINT_ID: "2"
          IMAGE: docker.io/${{ secrets.DOCKER_USERNAME }}/${{ secrets.CONTAINER_NAME }}:latest
          API_KEY: ${{ secrets.PORTAINER_API_TOKEN }}
          CONTAINER_NAME: ${{ secrets.CONTAINER_NAME }}

          # Host-Dateien (absolute Pfade)
          CONFIG_PATH: /home/js/snackbroker/data/.env     # z. B. /home/runner/env_prod
          TOKEN_PATH: /home/js/snackbroker/data/token.json       # z. B. /home/runner/token.json

          # Registry-Creds für Pull (falls Image privat; bei public unschädlich)
          REG_USER: ${{ secrets.DOCKER_USERNAME }}
          REG_PASS: ${{ secrets.DOCKER_PASSWORD }}

          # Ports
          CONTAINER_PORT: "8124"
          HOST_PORT: "8124"

          # Zielpfade im Container (ABSOLUT)
          CONTAINER_ENV_PATH: /broker/broker/data/.env
          CONTAINER_TOKEN_PATH: /broker/broker/data/token.json
        run: |
          set -euo pipefail
          command -v jq >/dev/null || { sudo apt-get update; sudo apt-get install -y jq; }
          
          # Eingangsprüfungen
          [ -f "$CONFIG_PATH" ] || { echo "Fehler: CONFIG_PATH ist keine Datei: $CONFIG_PATH"; exit 1; }
          [ -f "$TOKEN_PATH"  ] || { echo "Fehler: TOKEN_PATH ist keine Datei: $TOKEN_PATH"; exit 1; }
          
          curl_dbg() {
            # curl_dbg METHOD URL [DATA_JSON]
            local method="$1"; local url="$2"; local data="${3:-}"
            local resp body code
            if [ -n "$data" ]; then
              resp=$(curl --insecure -s -S -w "\n%{http_code}" -X "$method" \
                -H "X-API-Key: $API_KEY" -H "Content-Type: application/json" \
                "$url" -d "$data")
            else
              resp=$(curl --insecure -s -S -w "\n%{http_code}" -X "$method" \
                -H "X-API-Key: $API_KEY" "$url")
            fi
            body="$(printf "%s" "$resp" | sed '$d')"
            code="$(printf "%s" "$resp" | tail -n1)"
            echo "HTTP $code"
            if [ "$code" -ge 400 ]; then
              echo "---- Response body ----"
              echo "$body"
              echo "-----------------------"
              exit 1
            fi
            printf "%s" "$body"
          }
          
          # 1) Image PULL (vor Create), mit Registry-Auth Header
          AUTH_B64=$(printf '{"username":"%s","password":"%s"}' "$REG_USER" "$REG_PASS" | base64 -w0 2>/dev/null || printf '{"username":"%s","password":"%s"}' "$REG_USER" "$REG_PASS" | base64)
          echo "Pulle Image $IMAGE …"
          pull_resp=$(curl --insecure -s -S -w "\n%{http_code}" -X POST \
            -H "X-API-Key: $API_KEY" \
            -H "X-Registry-Auth: $AUTH_B64" \
            "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/images/create?fromImage=$IMAGE")
          pull_code="$(printf "%s" "$pull_resp" | tail -n1)"
          if [ "$pull_code" -ge 400 ]; then
            echo "HTTP $pull_code beim Pull"
            printf "%s" "$pull_resp" | sed '$d'
            exit 1
          fi
          echo "Image pull OK"
          
          # 2) Alten Container entfernen (idempotent)
          LIST_URL="$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/json?all=1"
          OLD_ID=$(curl --insecure -sS -H "X-API-Key: $API_KEY" "$LIST_URL" \
            | jq -r ".[] | select(.Names[]? == \"/$CONTAINER_NAME\") | .Id // empty")
          if [ -n "${OLD_ID:-}" ]; then
            echo "Stoppe alten Container $OLD_ID …"
            curl_dbg POST "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/$OLD_ID/stop" || true
            echo "Lösche alten Container $OLD_ID …"
            curl_dbg DELETE "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/$OLD_ID?force=1&v=1"
          fi
          
          # /home/runner/env_prod -> ENV Array für Docker
          ENV_ARR=$(jq -Rs '
            split("\n")
            | map(select(test("^\\s*$|^\\s*#")|not))        # leere Zeilen & Kommentare entfernen
            | map(gsub("^\\s+|\\s+$";""))                   # Whitespace trimmen
            | map(select(test("^[A-Za-z_][A-Za-z0-9_]*="))) # nur KEY=VALUE Zeilen behalten
          ' < "$CONFIG_PATH")
          
          # Container erstellen mit ENV + token.json
          CREATE_PAYLOAD=$(jq -n \
            --arg img "$IMAGE" \
            --arg tok_bind "${TOKEN_PATH}:${CONTAINER_TOKEN_PATH}:ro" \
            --arg cport "$CONTAINER_PORT" \
            --arg hport "$HOST_PORT" \
            --argjson env "$ENV_ARR" \
            '{
              "Image": $img,
              "Env": $env,
              "ExposedPorts": { ($cport + "/tcp"): {} },
              "HostConfig": {
                "PortBindings": { ($cport + "/tcp"): [ { "HostPort": $hport } ] },
                "Binds": ["/home/js/snackbroker/data:/broker/broker/data],
                "RestartPolicy": { "Name": "unless-stopped" }
              }
            }')
                    
          echo "Erzeuge Container $CONTAINER_NAME …"
          RESP=$(curl --fail --insecure -sS -X POST \
            "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/create?name=$CONTAINER_NAME" \
            -H "X-API-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "$CREATE_PAYLOAD")
          
          CID=$(echo "$RESP" | jq -r '.Id // empty')
          [ -n "$CID" ] || { echo "Fehler: Keine Container-ID im Create-Response"; echo "$RESP"; exit 1; }
          # Start: ohne Body (Portainer→Docker Engine)
          start_resp=$(curl --insecure -s -S -w "\n%{http_code}" -X POST \
            -H "X-API-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            --data '{}' \
            "$PORTAINER_URL/api/endpoints/$ENDPOINT_ID/docker/containers/$CID/start")
          start_code="$(printf "%s" "$start_resp" | tail -n1)"
          if [ "$start_code" -ge 400 ]; then
            printf "%s\n" "$start_resp" | sed '$d'; exit 1
          fi
          echo "Start OK"




